# Empowering Users: Iteration 2 of Our Smart Contract Wallet

Our first iteration laid a solid foundation, but there's always room for growth! In this second iteration, we tackled a crucial limitation â€“ empowering anyone, not just the wallet owner, to initiate transactions. This paves the way for innovative use cases like bundlers who can group transactions for efficiency.

### The Power of Signatures: Verifying Transaction Authenticity

To ensure security while enabling broader transaction initiators, we embraced the power of signatures. This allows users to construct, sign, and execute transactions with confidence. The wallet can then verify these signatures before execution, safeguarding against unauthorized actions.

### Introducing UserOperation: Streamlining Functionality

To improve code readability and maintainability, we introduced a new structure called UserOperation. This acts like a container, neatly organizing the parameters required by the execute function. Think of it as a well-organized toolbox, making the execution process more efficient for developers.

This second iteration represents a significant leap forward, granting greater flexibility and control over transactions within our Smart Contract Wallet. Stay tuned as we delve deeper into the exciting world of bundlers and explore how they can further optimize blockchain transactions!

### UserOperation

The **UserOperation** struct is a data structure introduced in our smart contract to encapsulate the parameters required for executing a transaction. It includes the following parameters:

`target`: This parameter represents the address of the target smart contract or account where the transaction will be executed.  
`value`: The value parameter specifies the amount of cryptocurrency or tokens (if applicable) to be transferred in the transaction.  
`_calldat`: This parameter contains the transaction data encoded as a byte array. It includes information about the function to be called and any parameters required for that function.  
`signature`: The signature parameter stores the cryptographic signature generated by the transaction initiator (e.g., the wallet owner). This signature is used to verify the authenticity of the transaction and ensure that it was indeed initiated by the owner.

In the context of our smart contract wallet, the UserOperation struct serves as a pivotal component for facilitating transaction execution. Initially, it encapsulates essential parameters required to execute a transaction, such as the target address, value to be transferred, transaction data, and cryptographic signature. This struct acts as a unified container, streamlining the process of passing transaction details to the execute function.

As we evolve our smart contract, we continuously refine and expand the functionality of the UserOperation struct to accommodate additional parameters and enhance its versatility. In future iterations, we plan to introduce more parameters to this struct to support advanced features and improve transaction customization. These additional parameters may include options for specifying gas limits, transaction deadlines, or conditional execution logic, depending on the specific requirements of our application.

By iteratively enhancing the UserOperation struct, we aim to create a robust and flexible framework that empowers users to execute transactions with greater control and precision. This iterative approach allows us to adapt to evolving use cases, incorporate user feedback, and ensure that our smart contract wallet remains adaptable and future-proof.

## Tests

In this section, we will delve into the testing script for the second iteration of our smart contract wallet. Let's break down the key points:

1.  The `deployWallet()` function is pivotal, and it remains unchanged for this iteration we can use the previous version of the function without a change.
2.  No change the first deployment test as well utilize the same test for testing the deployment of the smart contract wallet.
3.  We add a new test case to validate token transfers initiated by the owner, regardless of the sender. This ensures that token transfers occur as intended when initiated by the owner, even if the transaction is executed by another account.

```javascript
it("Transfer tokens when the owner signs the transaction, regardless of the sender", async function () {
  const { token, wallet, owner, otherAccount, anotherAccount } =
    await loadFixture(deployWallet);
  // Creating calldata with owner account
  const transferData = token
    .connect(owner)
    .interface.encodeFunctionData("transfer", [
      otherAccount.address,
      ethers.parseEther("100"),
    ]);
  // A new Hash function to get the hash of the data
  let messageHash = await wallet.getMessageHash(
    await token.getAddress(),
    0,
    transferData
  );
  // Signing the message with owner's account
  const signedMessage = await owner.signMessage(ethers.toBeArray(messageHash));
  // Executing the transaction with anotherAccount
  await wallet.connect(anotherAccount).execute({
    target: await token.getAddress(),
    value: 0,
    _calldata: transferData,
    signature: signedMessage,
  });
  let balance = await token.balanceOf(otherAccount.address);
  let walletBalance = await token.balanceOf(await wallet.getAddress());
  // Expect the balance to match
  expect(balance).to.equal(ethers.parseEther("100"));
  expect(walletBalance).to.equal(0);
});
```

we update the testing script to invoke the `execute` function on the contract using an object with parameters `{ target, value, _calldata, signature}`. This adjustment simplifies the testing process and improves the script's readability, enhancing its overall efficiency. Also a function to get the hash of the object is added to the contract so that we are utilize only one version of the hash function. The test confirms that the owner can be validated by the signature not the sending entity's public key. With this test the sender can pay for the gas and the owner dont need gas in the EOA.

## Development

### WalletV2 Contract

1. Lets create a `contracts/02_WalletV2.sol`, In this iteration, several key enhancements were made to the smart contract wallet. Firstly, a new struct called `UserOperation` was introduced in the contract, providing a structured approach to handle user transactions. Additionally, a new function named `getMessageHash` was added to the contract, facilitating the calculation of message hashes for transaction verification. Moreover, various signature verification functions, including `splitSignature`, `getEthSignedMessageHash`, and `recoverSigner`(Dont get too attached with the functions as they will be changed in next iterations) were implemented to ensure the integrity of signed transactions. Finally, the `execute` function underwent modifications to include additional checks for verifying the owner's signature before executing transactions, thereby enhancing the security and reliability of the smart contract wallet.

```javascript

struct UserOperation {
    address target;
    uint256 value;
    bytes _calldata;
    bytes signature;
}

contract WalletV2 is Ownable {
    ...

    function getEthSignedMessageHash(
        bytes32 _hash
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked("\x19Ethereum Signed Message:\n32", _hash)
            );
    }

    function getMessageHash(
        address _target,
        uint256 _value,
        bytes calldata _calldata
    ) public pure returns (bytes32) {
        return keccak256(abi.encode(_target, _value, _calldata));
    }

    function splitSignature(
        bytes memory _signature
    ) internal pure returns (uint8, bytes32, bytes32) {
        require(_signature.length == 65, "Invalid signature length");
        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            // First 32 bytes stores the length of the signature
            // Add 32 to get the next memory slot where the signature starts
            r := mload(add(_signature, 32))
            s := mload(add(_signature, 64))
            // The last byte of the signature contains the `v` parameter
            // (even=0, odd=1)
            v := byte(0, mload(add(_signature, 96)))
        }
        return (v, r, s);
    }

    function recoverSigner(
        bytes32 _message,
        bytes memory _signature
    ) internal pure returns (address) {
        uint8 v;
        bytes32 r;
        bytes32 s;
        (v, r, s) = splitSignature(_signature);
        return ecrecover(_message, v, r, s);
    }

    function execute(UserOperation calldata op) external {
        bytes32 messageHash = getMessageHash(op.target, op.value, op._calldata);
        bytes32 prefixedMessageHash = getEthSignedMessageHash(messageHash);
        require(
            recoverSigner(prefixedMessageHash, op.signature) == owner(),
            "Invalid signature"
        );
        _call(op.target, op.value, op._calldata);
    }
 ...
}
```

## Conclusion

### Building on Success: Iteration 2 of Our Smart Contract Wallet

Our initial version laid the groundwork, and iteration two builds upon that foundation! This time, we tackled a critical limitation: enabling anyone, not just the wallet owner, to initiate transactions. This opens doors for exciting possibilities like bundlers that optimize transaction processing.

- **Unlocking Flexibility**: Transactions Beyond the Owner
  Previously, only the wallet owner could initiate transactions. This iteration empowers any account to do so, paving the way for innovative use cases.

- **Security First**: Verifying Transaction Authenticity

Of course, security is paramount. To ensure only authorized transactions occur, we leverage the power of signatures. Users can now construct, sign, and execute transactions with confidence. The wallet acts as a gatekeeper, verifying these signatures before execution, preventing unauthorized actions.

- **Introducing UserOperation**: Streamlining Functionality

For improved code readability and maintainability, we introduced the UserOperation struct. This acts as a container, neatly organizing the information needed for the execute function. Think of it as a well-organized toolbox, making the development process more efficient.

### The Road Ahead: Refinement and Progress

This iteration represents a significant leap forward, granting greater flexibility and control over transactions. However, our journey continues! Here's where we'll focus next:

- **UserOperation in Focus**: We'll refine the UserOperation object, solidifying its role and functionality within the smart contract.
- **Leveraging External Libraries**: Currently, our verification relies on internal functions. To enhance efficiency and reliability, we'll explore integrating external libraries for hashing and signature verification.

### The Future of DeFi: A Secure and Efficient Wallet

Our ultimate goal is to create a Smart Contract Wallet that sets new standards in DeFi. Through continuous iteration, we'll refine features, address limitations, and leverage external libraries. Stay tuned as we push the boundaries of security, efficiency, and usability in the exciting realm of decentralized finance!

## References

1. [WalletV2.sol](contracts/02_WalletV2.sol)
2. [Test file](test/02_WalletV2.test.js)
